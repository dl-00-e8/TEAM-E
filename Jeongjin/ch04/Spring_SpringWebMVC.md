# Ch04 스프링과 스프링 Web MVC

## 4.1 의존성 주입과 스프링
스프링 프레임워크의 목표 : '경량(light weight) 프레임워크'

스프링 프레임워크는 가장 중요한 '코어(core)' 역할을 하는 라이브러리와 여러 개의 추가적인 라이브러리를 결합하는 형태로 프로젝트를 구성 

스프링이 객체지향 구조를 설계할 때 받아들인 개념 : '의존성 주입(Dependency Injection)'

의존성 주입 : 어떻게 하면 '객체와 객체 간의 관계를 더 유연하게 유지할 것인가?'에 대한 고민으로 객체의 생성과 관계를 효과적으로 분리할 수 있는 방법에 대한 고민 / 하나의 객체가 자신이 해야 하는 일을 하기 위해서 다른 객체의 도움이 필수적인 관계를 의미

스프링 프레임워크는 의존성을 해결하기 위해 프레임워크 자체에서 지원함

스프링 프레임워크는 추가하는 jar 파일에 따라서 사용할 수 있는 기능들이 달라짐

프레임워크 관련 라이브러리 버전은 구글을 이용해서 메이븐 저장소를 찾을 수 있음

라이브러리들을 추가할 때는 버전 통일 필요 (오작동 우려)

### 실습_01 의존성 주입하기
스프링 프레임워크는 자체적으로 객체를 생성하고 관리하면서 필요한 곳으로 객체를 주입하는 역할을 함 -> 이를 위해 설정 파일이나 어노테이션 등을 이용해야 함

스프링이 관리하는 객체들은 빈(Bean)이라는 이름으로 불리며, 프로젝트 내에서 어떤 빈(객체)들을 어떻게 관리할 것인지를 설정하는 설정 파일을 작성할 수 있습니다.

스프링으로 프로젝트를 구성하는 경우 상당히 많은 객체를 설정하기 때문에 나중에 한 번의 에러가 발생했을 때 원인을 찾으려고 하면 상당히 어려운 경우가 많기에, **가능하다면 개발 단계에서 많은 테스트를 진행하면서 개발하는 것이 좋다.**

빈 설정은 XML을 이용하거나 별도의 클래스를 이용하는 자바 설정 가능 -> root-context.xml 방식으로 실습

>@Autowired: 의존성 주입 관련 어노테이션 / '만일 해당 타입의 빈(Bean)이 존재하면 여기에 주입해 주기를 원한다'는 의미
>
>@ExtendWith(SpringExtensition.class) : JUnit5 버전에서 'spring-test'를 이용하기 위한 설정
>
>@ContextConfiguration : 스프링의 설정 정보를 로딩하기 위해서 사용 (XML 이용시 locataions 속성, 자바 설정 이용시 classes 속성 사용)

서블릿이 존재하는 공간 : 서블릿 컨텍스트(Servlet Context)
빈(객체) 관리 : ApplicationContext

In 실습
1. ApplicationContext는 root-context.xml을 이용해서 스프링이 실행되고, ApplicationContext객체가 생성
2. root-context,xml을 읽으면 SampleService와 SampleDAO가 \<bean>으로 저장되어 있기에, 해당 클래스의 객체를 생성해서 관리 시작 

테스트 실행 시, @Autowired가 처리된 부분에 맞는 타입의 빈(Bean)이 존재하는지를 확인하고 이를 테스트 코드 실행 시 주입하게 됨. => 필드 주입(Field Injection) 방식

### 실습_02 SampleDAO 주입하기
테스트 코드 실행 환경 구조
ch04_02.png 활용

**\<context:component-scan>** : 해당 패키지를 스캔해서 스프링의 어노테이션을 인식하는데 사용  
스프링을 이용할 때는 클래스를 작성하거나 객체를 직접 생성하지 않음. 해당 역할은 스프링 내부에서 이루어지며, ApplicationContext가 생성된 객체들을 관리

### 실습_03 @Service, @Repository
>@Controller: MVC의 컨트롤러를 위한 어노테이션
>
>@Service: 서비스 계층의 객체를 위한 어노테이션
>
>@Repository: DAO와 같은 객체를 위한 어노테이션
>
>@Component : 일반 객체나 유틸리티 객체를 위한 어노테이션

즉, 어노테이션을 이용하게 되면 스프링 설정은 '해당 패키지를 조사해서 클래스의 어노테이션을 이용'하는 설정으로 변경

**생성자 주입 방식**
- 주입 받아야 하는 객체의 변수는 final로 작성
- 생성자를 이용해서 해당 변수를 생성자의 파라미터로 지정
장점 : 객체를 생성할 때 문제가 발생하는지를 미리 확인할 수 있기 때문에 필드 주입이나 Setter 주입 방식보다 선호됨.

Lombok에서는 @RequiredArgsConstructor를 이용해 필요한 생성자 함수 자동으로 작성 가능

**인터페이스를 이용한 느슨한 결합**
인터페이스를 이용해서 나중에 다른 클래스의 객체로 쉽게 변경할 수 있도록 하는 것이 좋음.
추상화된 타입을 이용하라는 의미이며, 가장 대표적인 것이 인터페이스임.

### 실습_04 SampleDAO를 인터페이스로 변경하기
느슨한 결합(loose coupling) : 객체와 객체의 의존 관계의 실제 객체를 몰라도 가능하게 하는 방식

스프링의 빈이 두 개이상이면 어떤 빈을 사용해야 할지 몰라, 에러를 발생시키게 되는데, 이를 해결하기 위해서 사용할 수 있는 방법으로는 @Primary와 @Qualifier가 있다.

작성되는 모든 클래스의 객체가 스프링의 빈(Bean)으로 처리되는 것은 아니다. 
스프링의 빈(Bean)으로 등록되는 객체들은 '핵심 배역'을 하는 객체들이다. 주로 오랜 시간 동안 프로그램 내에 상주하면서 중요한 역할을 하는 '역할' 중심의 객체들을 말함.
그렇기에, '역할'보다 '데이터'에 중점을 두고 설게된 객체들은 스프링의 빈(Bean)으로 등록되지 않음.

코드를 수정할 수 있는가를 통해 XML과 어노테이션 중 어떤 방법으로 Bean을 처리할지 판단하면 됨.
Ex) jar파일로 추가되는 클래스의 객체를 스프링의 빈(Bean)으로 처리해양 한다면 해당 코드가 존재하지 않기 때문에 어노테이션을 추가할 수 없기에, XML이나 \<bean>에서 처리한다. 직접 작성되는 클래스는 어노테이션을 이용한다.

ApplicationContext 구조
ch04_p243.png 활용

ApplicationContext가 웹 애플리케이션에서 동작하려면 웹 애플리케이션이 실행될 때 스프링을 로딩해서 해당 웹 애플리케이션 내부에 스프링의 ApplicationContext를 생성하는 작업이 필요하게 됨. 이를 web.xml을 이용해서 리스너를 설정하게 됨
ch04_p243_2.png 활용

스프링 프레임워크의 웹과 관련된 작업은 'spring-webmvc' 라이브러리를 추가해야만 설정 가능

### 실습_05 DataSource 구성하기
MariaDB 이용시, MariaDB 드라이버와 HikariCP 관련 라이브러리 추가 필요

HikariCP를 사용하기 위해서는 HikariConfig 객체와 HikariDataSource를 초기화해야함.
스프링을 이용한다면 이 설정은 스프링의 빈(Bean)으로 처리되어야 함. root-context.xml을 이용하여 설정

스프링은 필요한 객체를 스프링에서 주입해 주기 때문에 개별적으로 클래스를 작성해서 빈(Bean)으로 등록해 두기만 하면 원하는 곳에서 쉽게 다른 객체를 사용 가능
그렇기에, 전체 애플리케이션의 구조를 설계할 때 스프링 프레임워크 사용

## 4.2 MyBatis와 스프링 연동
MyBatis : Sql Mapping Framework / SQL의 실행 결과를 객체지향으로 '매핑'해준다는 의미

### MyBatis의 편리한 점
- PreparedStatement/ResultSet의 처리: 기존에 프로그램을 작성해서 하나씩 처리해야 하는 파라미터나 ResultSet의 getXXX()를 MyBatis가 알아서 처리해 주기에 많은 양의 코드를 줄일 수 있음
- Connection/PreparedStatement/ResultSet의 close() 처리: MyBatis와 스프링을 연동해서 사용하는 방식을 이용하면 자동으로 close() 처리를 할 수 있음
- SQL의 분리: MyBatis를 이용하면 별도의 파일이나 어노테이션 등을 이용해서 SQL을 선언합니다. 파일을 이용하는 경우에는 SQL을 별도의 파일로 분리해 운영이 가능함

### MyBatis와 스프링의 연동 방식
- MyBatis를 단독으로 개발하고 스프링에서 DAO를 작성해서 처리하는 방식: 기존의 DAO에서 SQL의 처리를 MyBatis를 이용하는 구조로써 완전히 MyBatis와 스프링 프레임워크를 독립적인 존재로 바라보고 개발하는 방식
- MyBatis와 스프링을 연동하고 Mapper 인터페이스만 이용하는 방식: 스프링과 MyBatis 사이에 'mybatis-spring'이라는 라이브러리를 이용해서 스프링이 데이터베이스 전체에 대한 처리를 하고 MyBatis를 일부 기능 개발에 활용하는 방식 / 개발 시에는 Mapper 인터페이스라는 방식을 이용해서 인터페이스만으로 모든 개발이 가능한 방식

최소한의 코드로 개발 가능한 방식: 'mybatis-spring'

### MyBatis를 위해 필요한 라이브러리들
- 스프링 관련: spring-jdbc, spring-tx
- MyBatis 관련: mybatis, mybatis-spring (mybatis와 mybatis-spring 라이브러리의 버전은 일치하지 않음)

### SqlSessionFactory
MyBatis를 이용하기 위해서는 스프링에 설정해둔 HikariDataSource를 이용해서 SqlSessionFactory라는 빈(Bean)을 설정해야함

### 실습_01 Mapper 인터페이스 활용하기
MyBatis는 SQL 파일을 별도로 처리할 수 있지만, 인터페이스와 어노테이션만으로도 처리가 가능함

MyBatis에는 @Select 어노테이션을 이용해서 쿼리를 작성할 수 있는데, ";"을 이용하지 않는다는 것을 주의해야 함

Mapper Interface를 만들었으므로, root-context.xml에 등록 필요

클래스와 객체를 스프링에서 자동으로 생성되는 방식을 이용하게 되므로, 개발자가 직접 코드를 수정할 수 없다는 단점이 있기는 하지만, 인터페이스만으로도 개발을 완료할 수 있다는 장점도 있음.

### 실습_02 XML로 SQL 분리하기
SQL을 별도의 파일로 분리하는 것을 권장 (SQL이 길어지면 이를 어노테이션으로 처리하기가 복잡해지기 때문 + 어노테이션이 나중에 변경되면 프로젝트 전체를 다시 빌드하는 작업이 필요해짐)

XML과 매퍼 인터페이스를 결합하는 과정
1. 매퍼 인터페이스를 정의하고 메소드 선언
2. 해당 XML 파일을 작성(파일 이름과 매퍼 인터페이스 이름을 같게)하고 \<select>와 같은 태그를 이용해서 SQL을 작성
3. \<select>, \<insert> 등의 태그에 id 속성 값을 매퍼 인터페이스의 메소드 이름과 같게 작성

## 4.3 스프링 Web MVC 기초
스프링 Web MVC(= 스프링 MVC)는 Web MVC 패턴으로 구현된 구조임.

스프링 MVC가 기본 구조에 약간의 변화를 주는 부분
- Front-Controller 패턴을 이용해서 모든 흐름의 사전/사후 처리를 가능하도록 설계된 점
- 어노테이션을 적극적으로 활용해서 최소한의 코드로 많은 처리가 가능하도록 설계된 점
- HttpServletRequest/HttpServletResponse를 이용하지 않아도 될 만큼 추상화된 방식으로 개발 가능

스프링 MVC의 전체 흐름
ch04_p259.png 활용

**스프링 MVC에서 가장 중요한 사실 : 모든 요청(Request)이 반드시 DispatcherServlet이라는 존재를 통해서 실행된다는 사실**
--> 모든 흐름이 하나의 객체를 통해서 진행되는 패턴 : 퍼사드(facade) 패턴 / 웹 구조에서는 'Front-Controller 패턴'이라고 부름

모든 공통적인 처리를 프론트 컨트롤러에서 처리할 수 있게 됨.

스프링 MVC에서는 DispatchServlet이라는 객체가 프론트 컨트롤러의 역할을 수행함.
ch04_p260.png 활용

프론트 컨트롤러가 사전/사후에 대한 처리를 하게 되면 중간에 매번 다른 처리를 하는 부분만 별도로 처리하는 구조를 만들게 됩니다. 이를 컨트롤러라 하며 @Controller를 이용해서 처리함

### 실습_01 스프링 MVC 사용하기
스프링 MVC를 실행하려면 프론트 컨트롤러의 역할을 하는 DispatcherServlet을 설정해 주어야만 하며, 이를 web.xml을 이용해서 처리함

### 실습_02 스프링 MVC 컨트롤러
스프링 MVC의 컨트롤러들의 특징
- 상속이나 인터페이스를 구현하는 방식을 사용하지 않고 어노테이션만으로 처리가 가능
- 오버라이드 없이 필요한 메소드들을 정의
- 메소드의 파라미터를 기본 자료형이나 객체 자료형을 마음대로 지정
- 메소드의 리턴타입도 void, String, 객체 등 다양한 타입을 사용할 수 있음

특이 어노테이션
- @Controller: 해당 클래스가 스프링 MVC에서 컨트롤러 역할을 한다는 것을 의미하고 스프링의 빈(Bean)으로 처리되기 위해서 사용
- @GetMapping: GET 방식으로 들어오는 요청(Request)를 처리하기 위해서 사용
- @RequestMapping : 특정한 경료의 요청(Request)를 지정하기 위해서 사용 / 컨트롤러 클래스의 선언부와 메소드 모두 사용 가능 
- @GetMapping/@PostMapping : get/post 방식을 구분해서 @RequestMapping을 처리

### 실습_03 단순 파라미터의 자동 수집
파라미터 자동 수집 : DTO나 VO 등을 메소드의 파라미터로 설정하면 자동으로 전달되는 HttpServletRequest의 파라미터들을 수집해주는 기능
파라미터 자동 수집 기준
- 기본 자료형의 경우는 자동으로 형 변환처리가 가능
- 객체 자료형의 경우는 setXXX()의 동작을 통해서 처리
- 객체 자료형의 경우 생성자가 없거나 파라미터가 없는 생성자가 필요 (Java Beans)

Model이라는 데이터를 JSP까지 전달할 필요가 있다.
스프링 MVC에서는 Model이라는 객체를 파라미터로 이용해서 처리할 수 있음

PRG패턴: Post 방식으로 어떤 처리를 하고 Redirect를 해서 GET 방식으로 특정한 페이지로 이동하는 패턴
-> 스프링 MVC에서는 RedirectAttributes라는 특별한 타입을 제공
RedirectAttributes 중요 메소드
- addAttribute(키, 값): 리다이렉트할 때 쿼리 스트링이 되는 값을 지정 / 리다이렉트할 URL에 쿼리 스트링으로 추가됨
- addFlashAttribute(키, 값): 일회용으로만 데이터를 전달하고 삭제되는 값을 지정 / URL에 보이지 않지만, JSP에서는 일회용으로 사용할 수 있음

스프링 MVC에서 주로 사용하는 리턴 타입
- void: 일반적으로 화면이 따로 있는 경우 / 컨트롤러의 @RequestMapping 값과 @GetMapping 등 메소드에서 선언된 값을 그래도 뷰(View)의 이름으로 사용 / 주로 상황에 관계없이 동일한 화면을 보여주는 경우에 사용
- 문자열: 일반적으로 화면이 따로 있는 경우 / 상황에 따라 다른 화면을 보여주는 경우에 사용 / 접두어 redirect(리다이렉션을 이용하는 경우), forward(브라우저의 url은 고정하고 내부적으로 다른 URL로 처리하는 경우) 사용 가능
- 객체나 배열, 기본 자료형: JSOn 타입을 활용할 경우
- ResponseEnity: JSOn 타입을 활용할 경우

### 스프링 MVC에서 주로 사용하는 어노테이션들
- 컨트롤러 선언부에 사용하는 어노테이션
> @Controller: 스프링 빈의 처리됨을 명시
> @RestController: REST 방식의 처리를 위한 컨트롤러임을 명시
> @RequestMapping: 특정한 URL

- 메소드 선언부에 사용하는 어노테이션
> @GetMapping/@PostMapping/@DeleteMapping/@PutMapping..: HTTP 전송 방식에 따라 해당 메소드를 지정하는 경우에 사용, 일반적으로 @GetMapping과 @PostMapping이 주로 사용
> @RequestParam: Request에 있는 특정한 이름의 데이터를 파라미터로 받아서 처리하는 경우에 사용
> @PathVariable: URL 경로의 일부를 변수로 삼아서 처리하기 위해서 사용
> @ModelAttribute: 해당 파라미터는 반드시 Model에 포함되어서 다시 뷰(View)로 전달됨을 명시
> 기타: @SessionAttribute, @Valid, @RequestBody 등

## 4.4 스프링 Web MVC 구현하기